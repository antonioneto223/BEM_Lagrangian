	SUBROUTINE INPUT_DATA
!     
    INCLUDE 'link_fnl_static.h'
    !DEC$ OBJCOMMENT LIB:'libiomp5md.lib'
!      
	USE NURBS_SURFACES
	USE TRIMMING_CURVES
    USE ISOPARAMETRIC_MESH
	USE MATERIALS
	USE CRACKS_DUAL_BEM
	USE SUB_REGIONS_INTERFACES
	USE ANALYSIS
	USE REMESHING
	USE PROPAGATION
	USE FATIGUE
    USE XBEM_CRACKFRONT_VARIABLES
    USE COHESIVE
    USE REINFORCEMENTS
    USE VISCO    
    
!
	IMPLICIT NONE 
!
    CHARACTER*30::LIXO
!
    INTEGER::I,J,K,II,JJ,KK,NEN,KVSIZE1,KVSIZE2,MAX_KVSIZE1,MAX_KVSIZE2,MAX_NCP,KVSIZE,MAX_KVSIZE,IOS
!
    REAL*8::X,Y,Z,DX,DY,DZ,DR,NIAUX[ALLOCATABLE](:,:),VALUES[ALLOCATABLE](:,:),&
    PHI[ALLOCATABLE](:),DPHI[ALLOCATABLE](:,:),D2PHI[ALLOCATABLE](:,:,:),COEFFICIENTS[ALLOCATABLE](:,:),PERCENTAGE_EXPONENTIAL
!
    CHARACTER*30::GEOMETRY_FILE,BOUNDARYCONDITIONS_FILE,MATERIALS_FILE,ANALYSIS_FILE
!
    LOGICAL::INPUTFILE
!   
    LOGICAL::SOURCE_POINT_SPACING[ALLOCATABLE](:)
    REAL*8::QSIW_GAUSS[ALLOCATABLE](:,:),AELEM,VJAC(3),DVJAC(3,2),JAC,ETA(3)     
!	         
3	WRITE(*,*)
	WRITE(*,*)'PLEASE, INFORM THE INPUT FILE NAME'
	READ(*,1)INPUT_FILE
1	FORMAT(A30)

	INQUIRE(FILE=TRIM(INPUT_FILE),EXIST=INPUTFILE)
	IF(INPUTFILE)THEN
		OPEN(10,FILE=INPUT_FILE,STATUS='UNKNOWN')
	ELSE
		WRITE(*,*)''
		WRITE(*,*)'**************************************************'
		WRITE(*,*)'INPUT DATA ERROR'
		WRITE(*,*)'FILE NON IDENTIFIED'
		WRITE(*,*)'PLEASE, VERIFY IT AND TRY AGAIN'
		WRITE(*,*)'**************************************************'
		PAUSE
!
		DO I=1,22
			WRITE(*,*)''
		ENDDO
		GO TO 3
	ENDIF
!
!	INPUT DATA FILE		
!
    READ(10,*)!*************** MAIN LIST OF INPUT DATA *******************************
    READ(10,*)!
    READ(10,*)!SPECIFY THE NAME OF THE FILE CONTAINNING THE GEOMETRY
    READ(10,*)GEOMETRY_FILE
    READ(10,*)!
    READ(10,*)!SPECIFY THE NAME OF THE FILE CONTAINNING THE  BOUNDARY CONDITIONS
    READ(10,*)BOUNDARYCONDITIONS_FILE
    READ(10,*)!
    READ(10,*)!SPECIFY THE NAME OF THE FILE CONTAINNING THE MATERIAL PARAMETERS
    READ(10,*)MATERIALS_FILE
    READ(10,*)!
    READ(10,*)!SPECIFY THE NAME OF THE FILE CONTAINNING THE PARAMETERS OF ANALYSIS
    READ(10,*)ANALYSIS_FILE     
    READ(10,*,IOSTAT=IOS)!
    READ(10,*,IOSTAT=IOS)!SPECIFY THE NAME OF THE FILE CONTAINING THE REINFORCEMENTS DATA
    READ(10,*,IOSTAT=IOS)FILE_REINFORCEMENTS
    IF(IOS.NE.0) EXISTANCE_REINFORCEMENTS = 'N'
    CLOSE(10) 
        
    INQUIRE(FILE=TRIM('Input_data\'//GEOMETRY_FILE),EXIST=INPUTFILE) 
    IF(INPUTFILE)THEN
      OPEN(1,FILE='Input_data\'//GEOMETRY_FILE,STATUS='UNKNOWN')
	ELSE
      WRITE(*,*)'THE GEOMETRY FILE DOES NOT EXIST'
      WRITE(*,*)'VERIFY THE INPUT FOLDER'
      WRITE(*,*)'THE PROGRAM IS FINISHED'
      PAUSE
      STOP
    ENDIF
!      	 
    READ(1,*)! **************** GEOMETRY DEFINITIONS *****************
    READ(1,*)!WARNING: RESPECT THIS FILE FORMAT.THE SPACE BETWEEN DATA
    READ(1,*)!AND THE NUMBER FORMAT
	READ(1,*)!
	READ(1,*)! NUMBER OF DOMAINS:
	READ(1,*)N_DOMAINS
	READ(1,*)!
	READ(1,*)! NUMBER OF NURBS SURFACES:
	READ(1,*)N_SURFACES
	READ(1,*)!
	READ(1,*)!NUMBER OF SURFACES CONTROL POINTS:
	READ(1,*)N_CONTROLPOINTS
	READ(1,*)!
	READ(1,*)! NUMBER OF NURBS PARAMETRIC TRIMMING CURVES:
	READ(1,*)N_TRIMMINGCURVES
	READ(1,*)!
	READ(1,*)!NUMBER OF TRIMMING CURVES PARAMETRIC CONTROL POINTS:
	READ(1,*)N_PARAMETRICCONTROLPOINTS
	READ(1,*)!		
!
!	ALLOCATING SOME VARIABLES 
!
	ALLOCATE(N_BF(N_SURFACES,2),POLYNOMIAL_ORDERS(N_SURFACES,2),N_GBF(N_SURFACES),COORD_CONTROLPOINTS(N_CONTROLPOINTS,4),SUBDIVISION_PD1(N_SURFACES),SUBDIVISION_PD2(N_SURFACES),DOMAINS(N_SURFACES),SURFACE_TYPE(N_SURFACES),TRIMMED_SURFACE(N_SURFACES),N_COLLOCPOINTS_SURFACES(N_SURFACES),N_ELEM_SURFACES(N_SURFACES),SURFACE_INVERTION(N_SURFACES))
	ALLOCATE(N_BFCURVES(N_TRIMMINGCURVES),POLYNOMIAL_ORDER(N_TRIMMINGCURVES),COORD_PARAMETRICCONTROLPOINTS(N_PARAMETRICCONTROLPOINTS,3),SUBDIVISION(N_TRIMMINGCURVES),SURFACES(N_TRIMMINGCURVES),OPENED_CLOSED_CURVE(N_TRIMMINGCURVES),LAST_OPENED_CURVE(N_TRIMMINGCURVES))	
    ALLOCATE(DESCONT_TYPE(N_SURFACES))
    DESCONT_TYPE=""
!
	READ(1,*)! SURFACES CONTROL POINTS COORDINATES AND WEIGHTS:
	READ(1,*)! CONTROL POINT		  X                Y                Z                W        
!
	DO I=1,N_CONTROLPOINTS
	   READ(1,*)II,COORD_CONTROLPOINTS(II,1),COORD_CONTROLPOINTS(II,2),COORD_CONTROLPOINTS(II,3),COORD_CONTROLPOINTS(II,4)
	ENDDO
!
    READ(1,*)!
    READ(1,*)! NUMBER OF UNIVARIATE BASIS FUNCTIONS (n,m) AND POLYNOMIAL ORDERS (p,q) FOR EACH NURBS SURFACE PATCH:
    READ(1,*)! PATCH          n           m         ORDER p     ORDER q
	DO I=1,N_SURFACES
	   READ(1,*)II,N_BF(II,1),N_BF(II,2),POLYNOMIAL_ORDERS(II,1),POLYNOMIAL_ORDERS(II,2)
	ENDDO
!
!	COMPUTING N_GBF
!
    DO I=1,N_SURFACES
        N_GBF(I)=N_BF(I,1)*N_BF(I,2)
    ENDDO	
!
!	ALLOCATING THE KNOT_VECTORS
!
    MAX_KVSIZE1=0
    MAX_KVSIZE2=0  
	DO I=1,N_SURFACES
	    KVSIZE1=N_BF(I,1)+POLYNOMIAL_ORDERS(I,1)+1
	    IF(KVSIZE1.GE.MAX_KVSIZE1)THEN
	        MAX_KVSIZE1=KVSIZE1
	    ENDIF	    
	    KVSIZE2=N_BF(I,2)+POLYNOMIAL_ORDERS(I,2)+1	    
	    IF(KVSIZE2.GE.MAX_KVSIZE2)THEN
	        MAX_KVSIZE2=KVSIZE2
	    ENDIF		    
	ENDDO   
	ALLOCATE(KNOT_VECTORS(N_SURFACES,2,MAX(MAX_KVSIZE1,MAX_KVSIZE2)))
	KNOT_VECTORS=0.D0    	
!
    READ(1,*)!    
    READ(1,*)! KNOT VECTORS OF THE SURFACE PATCHES 
    READ(1,*)! PATCH     KNOT VECTORS  
!
	DO I=1,N_SURFACES
	   KVSIZE1=N_BF(I,1)+POLYNOMIAL_ORDERS(I,1)+1
	   KVSIZE2=N_BF(I,2)+POLYNOMIAL_ORDERS(I,2)+1
	   READ(1,*)II,(KNOT_VECTORS(II,1,J),J=1,KVSIZE1)
	   READ(1,*)II,(KNOT_VECTORS(II,2,J),J=1,KVSIZE2)    
	ENDDO	
!
!	ALLOCATING THE CONTROLPOINTS_CONECTIVITY 
!
    MAX_NCP=0
	DO I=1,N_SURFACES
	    IF(N_GBF(I).GE.MAX_NCP)THEN
	        MAX_NCP=N_GBF(I)
	    ENDIF
	ENDDO   
	ALLOCATE(CONTROLPOINTS_CONNECTIVITY(N_SURFACES,MAX_NCP))
!	        
	READ(1,*)!
    READ(1,*)! SURFACE CONTROL POINTS CONNECTIVITY
	READ(1,*)! PATCH     CONTROL POINTS	
	DO I=1,N_SURFACES	
	   READ(1,*)II,(CONTROLPOINTS_CONNECTIVITY(II,J),J=1,N_GBF(II))  
    ENDDO	
    READ(1,*)!
    READ(1,*)! DOMAIN THAT EACH NURB SURFACE BELONG AND SURFACE TYPE:
    READ(1,*)! PATCH        DOMAIN         SURFACES [BOUNDARY(B), INTERFACE(I), COHESIVE INTERFACE(CI), CRACK SIDE D(CD), CRACK SIDE T(CT)]
    DO I=1,N_SURFACES
        READ(1,*,IOSTAT=IOS)II,DOMAINS(II),SURFACE_TYPE(II),DESCONT_TYPE(II)
        WRITE (LIXO, "(I0)") I+1
        IF (TRIM(DESCONT_TYPE(II)).EQ.TRIM(LIXO)) THEN
            BACKSPACE(1)
            DESCONT_TYPE(II)=""
        ENDIF
    ENDDO 
    IF (DESCONT_TYPE(N_SURFACES).NE."DB") THEN ! SE TIVER OUTROS VALORES POSSIVEIS PARA DESCONT_TYPE TEM QUE COLOCAR AQUI!!!!!
        DESCONT_TYPE(N_SURFACES)=""
        BACKSPACE(1)
        BACKSPACE(1)
    ENDIF
!	        
	READ(1,*)!
	READ(1,*)! SURFACE SUBDIVISION/REFINEMENT:
    READ(1,*)! PATCH       PARAMETRIC DIRECTION 1       PARAMETRIC DIRECTION 2  
    DO I=1,N_SURFACES
        READ(1,*)II,SUBDIVISION_PD1(II),SUBDIVISION_PD2(II)	
	ENDDO	
!	        
	READ(1,*)!
	READ(1,*)! UNTRIMMED/TRIMMED NURBS SURFACES:
    READ(1,*)! PATCH     UNTRIMMED/TRIMMED                    
	DO I=1,N_SURFACES
        READ(1,*)II,TRIMMED_SURFACE(II)	
	ENDDO
!	        
	READ(1,*)!
	READ(1,*)! SURFACE INVERTION:
    READ(1,*)! PATCH     INVERTION SIGN [INVERTED(-1), NOT INVERTED(1)]                 
	DO I=1,N_SURFACES
        READ(1,*)II,SURFACE_INVERTION(II)	
	ENDDO	
!
    READ(1,*)!
	READ(1,*)! PARAMETRIC TRIMING CURVES CONTROL POINTS COORDINATES AND WEIGHTS:
	READ(1,*)! CONTROL POINT		QSI1             QSI2              W        
	DO I=1,N_PARAMETRICCONTROLPOINTS
	   READ(1,*)II,COORD_PARAMETRICCONTROLPOINTS(II,1),COORD_PARAMETRICCONTROLPOINTS(II,2),COORD_PARAMETRICCONTROLPOINTS(II,3)
	ENDDO
!
    READ(1,*)!
    READ(1,*)! NUMBER OF UNIVARIATE BASIS FUNCTIONS (n) AND POLYNOMIAL ORDERS (p) FOR EACH TRIMING NURBS CURVES:
    READ(1,*)! PATCH          n         ORDER p
	DO I=1,N_TRIMMINGCURVES
	   READ(1,*)II,N_BFCURVES(II),POLYNOMIAL_ORDER(II)
	ENDDO
!
!	ALLOCATING THE KNOT_VECTOR
!
    MAX_KVSIZE=0
	DO I=1,N_TRIMMINGCURVES
	    KVSIZE=N_BFCURVES(I)+POLYNOMIAL_ORDER(I)+1
	    IF(KVSIZE.GE.MAX_KVSIZE)THEN
	        MAX_KVSIZE=KVSIZE
	    ENDIF	    		    
	ENDDO   
	ALLOCATE(KNOT_VECTOR(N_TRIMMINGCURVES,MAX_KVSIZE))
	KNOT_VECTOR=0.D0 	
!
    READ(1,*)!    
    READ(1,*)! KNOT VECTORS OF THE CURVES PATCHES 
    READ(1,*)! PATCH     KNOT VECTORS  
!
	DO I=1,N_TRIMMINGCURVES
	   KVSIZE=N_BFCURVES(I)+POLYNOMIAL_ORDER(I)+1
	   READ(1,*)II,(KNOT_VECTOR(II,J),J=1,KVSIZE)   
	ENDDO	
!
!	ALLOCATING THE PARAMETRICCONTROLPOINTS_CONECTIVITY 
!
    MAX_NCP=0
	DO I=1,N_TRIMMINGCURVES
	    IF(N_BFCURVES(I).GE.MAX_NCP)THEN
	        MAX_NCP=N_BFCURVES(I)
	    ENDIF
	ENDDO   
	ALLOCATE(PARAMETRICCONTROLPOINTS_CONNECTIVITY(N_TRIMMINGCURVES,MAX_NCP))
!	        
	READ(1,*)!
	READ(1,*)! TRIMMING CURVES CONTROL POINTS CONNECTIVITY
    READ(1,*)! PATCH     CONTROL POINTS	
	DO I=1,N_TRIMMINGCURVES
	   READ(1,*)II,(PARAMETRICCONTROLPOINTS_CONNECTIVITY(II,J),J=1,N_BFCURVES(I))   
	ENDDO
!	        
	READ(1,*)!
	READ(1,*)! SURFACE THAT EACH TRIMING NURB CURVE BELONG:
    READ(1,*)! PATCH       SURFACE                     
	DO I=1,N_TRIMMINGCURVES
        READ(1,*)II,SURFACES(II)	
	ENDDO 
!	        
	READ(1,*)!
	READ(1,*)! TRIMMING CURVES SUBDIVISION/REFINEMENT:
    READ(1,*)! PATCH       PARAMETRIC DIRECTION 1 
    DO I=1,N_TRIMMINGCURVES
        READ(1,*)II,SUBDIVISION(II)	
	ENDDO	
!	        
	READ(1,*)!
	READ(1,*)! OPENED(O) OR CLOSED(C) TRIMMING CURVES:
    READ(1,*)! PATCH       OPENED/CLOSED       LAST_CURVE  
    DO I=1,N_TRIMMINGCURVES
        READ(1,*)II,OPENED_CLOSED_CURVE(II),LAST_OPENED_CURVE(II)	
    ENDDO	
!
    READ(1,*,IOSTAT=IOS)!
    READ(1,*,IOSTAT=IOS)! NUMBER OF INTERNAL POINTS
    READ(1,*,IOSTAT=IOS)INPUT_INT_NODES
    IF (IOS.NE.0) INPUT_INT_NODES=0
    
    IF (INPUT_INT_NODES .NE. 0) THEN
        ALLOCATE(COORDINT_NOD_INPUT(INPUT_INT_NODES,3),NDI_INPUT(INPUT_INT_NODES))
        READ(1,*)!
        READ(1,*)! DEFINE INTERNAL POINTS
        READ(1,*)!   N     X    Y    Z    DOMAIN
        DO I=1,INPUT_INT_NODES
            READ(1,*)II,COORDINT_NOD_INPUT(II,1),COORDINT_NOD_INPUT(II,2),COORDINT_NOD_INPUT(II,3),NDI_INPUT(II)
        ENDDO
    ENDIF
!			 	
    CLOSE(1)
!    
    CALL MESH_GENERATION   		   		    
!   
    INQUIRE(FILE=TRIM('Input_data\'//BOUNDARYCONDITIONS_FILE), EXIST=INPUTFILE)
    IF(INPUTFILE)THEN
      OPEN(1,FILE='Input_data\'//BOUNDARYCONDITIONS_FILE,STATUS='UNKNOWN')
	ELSE
      WRITE(*,*)'THE BOUNDARY CONDITIONS FILE DOES NOT EXIST'
      WRITE(*,*)'VERIFY THE INPUT FOLDER'
      WRITE(*,*)'THE PROGRAM IS FINISHED'
      PAUSE
      STOP
    ENDIF
!      
    READ(1,*)!**************** BOUNDARY CONDITIONS ***********************
    READ(1,*)!WARNING: RESPECT THIS FILE FORMAT.THE SPACE BETWEEN DATA
    READ(1,*)!AND THE NUMBER FORMAT
    READ(1,*)!
    READ(1,*)!SPECIFY THE NUMBER OF LOAD PHASES
    READ(1,*)N_LOAD_FASE
    READ(1,*)!
    CALL UPDATE_LOAD_FASE    
    CLOSE(1)
!
    INQUIRE(FILE=TRIM('Input_data\'//MATERIALS_FILE),EXIST=INPUTFILE)
    IF(INPUTFILE)THEN
		OPEN(1,FILE='Input_data\'//MATERIALS_FILE,STATUS='UNKNOWN')
	ELSE
        WRITE(*,*)'THE MATERIAL FILE DOES NOT EXIST'
        WRITE(*,*)'VERIFY THE INPUT FOLDER'
        WRITE(*,*)'THE PROGRAM IS FINISHED'
        PAUSE
        STOP
    ENDIF
!      
    READ(1,*)!**************** MATERIAL DEFINITIONS ***********************
    READ(1,*)!WARNING: RESPECT THIS FILE FORMAT.THE SPACE BETWEEN DATA
    READ(1,*)!AND THE NUMBER FORMAT
    ALLOCATE(EMP(N_DOMAINS,2),FFMP(N_DOMAINS,4))
    ALLOCATE(EMP_VISCO(N_DOMAINS,2),TIME_MODEL(N_DOMAINS))
    READ(1,*)!      
	READ(1,*)!ELASTIC MATERIAL PROPERTIES
	READ(1,*)!DOMAIN		YOUNG'S MODULUS		POISON'S RATIO	GAMA    EVE(BOLTZMAN)   TIME MODEL    
	DO I=1,N_DOMAINS
        READ(1,*)II,EMP(II,1),EMP(II,2),EMP_VISCO(II,1),EMP_VISCO(II,2),TIME_MODEL(II)
	ENDDO	
	READ(1,*)!      
	READ(1,*)!FATIGUE AND FRACTURE MATERIAL PROPERTIES
	READ(1,*)!DOMAIN	       KIC        C        n        DKth	      	     
	DO I=1,N_DOMAINS
        READ(1,*)II,FFMP(II,1),FFMP(II,2),FFMP(II,3),FFMP(II,4)
    ENDDO
    READ(1,*)!      
	READ(1,*)!COHESIVE CRACK MATERIAL PROPERTIES
    READ(1,*)!NUMBER OF INTERFACES
    READ(1,*)NUMBER_INTERFACES
    ALLOCATE(ND_INT(NUMBER_INTERFACES,2),CM_TYPE(NUMBER_INTERFACES),CMP(NUMBER_INTERFACES,3))
    READ(1,*)! 
	READ(1,*)!DOMAIN1   DOMAIN2		COHESIVE LAW	F_T        G_F 	     
    PERCENTAGE_EXPONENTIAL=1.d-2
	IF(NUMBER_INTERFACES.GT.0)THEN
        DO I=1,NUMBER_INTERFACES
            READ(1,*)ND_INT(I,1),ND_INT(I,2),CM_TYPE(I),CMP(I,1),CMP(I,2),CMP(I,3)
            IF(TRIM(CM_TYPE(I)).EQ."BILINEAR")THEN
                CMP(I,2)=3.6D0*CMP(I,3)/CMP(I,1)
            ELSEIF(TRIM(CM_TYPE(I)).EQ."EXPONENTIAL")THEN
                CMP(I,2)=CMP(I,3)/CMP(I,1)*DLOG(1.D0/PERCENTAGE_EXPONENTIAL)
            ENDIF
        ENDDO
    ENDIF
    CLOSE(1)
!    
    INQUIRE(FILE=TRIM('Input_data\'//ANALYSIS_FILE),EXIST=INPUTFILE)
    IF(INPUTFILE)THEN
		OPEN(1,FILE='Input_data\'//ANALYSIS_FILE,STATUS='UNKNOWN')
	ELSE
        WRITE(*,*)'THE ANALYSIS FILE DOES NOT EXIST'
        WRITE(*,*)'VERIFY THE INPUT FOLDER'
        WRITE(*,*)'THE PROGRAM IS FINISHED'
        PAUSE
        STOP
    ENDIF
      
    READ(1,*)!**************** ANALYSIS DEFINITIONS ***********************
    READ(1,*)!WARNING: RESPECT THIS FILE FORMAT.THE SPACE BETWEEN DATA
    READ(1,*)!AND THE NUMBER FORMAT
    READ(1,*)!
    READ(1,*)!NUMBER OF GAUSS POINTS FOR INTEGRATION
    READ(1,*)N_GAUSSPOINTS
    READ(1,*)!
    READ(1,*)!PERCENTAGE DISTANCE OF THE COLLOCATION POINT AND THE BOUNDARY
    READ(1,*)DIST
    READ(1,*)!
    READ(1,*)!NUMBER OF PROPAGATION STEPS
    READ(1,*)N_STEPS     
    READ(1,*)!
    READ(1,*)!MAXIMUM CRACK INCREMENT
    READ(1,*)MAX_CRACKINCREMENT 
    READ(1,*)!    
    READ(1,*)!ANALYSIS TYPE: "ELASTIC", "BRITTLE_FRACTURE" OR "FATIGUE"
    READ(1,*)ANALYSIS_TYPE
    READ(1,*)!    
    READ(1,*)!STRESS INTENSITY FACTORS EXTRACTION: "DET" OR "DFT"
    READ(1,*)SITEXTRACTION_METHOD
    READ(1,*)!    
    READ(1,*)!NUMBER OF INTERNAL POINTS AND RADIUS FOR STRESS INTENSITY FACTORS EXTRACTION (DFT)
    READ(1,*)!N     RADIUS
    READ(1,*)N_SITEXTRACTION_POINTS,INTPOINTS_RADIUS   
    READ(1,*)!    
    READ(1,*)!CRACK PROPAGATION CRITERIA: MAXIMUM ENERGY RELEASE RATE "MERR" OR MAXIMUM PRINCIPAL STRESS "MPS"
    READ(1,*)PROPAGATION_CRITERIA       
    READ(1,*)!    
    READ(1,*)!FATIGUE LOAD RATIO: "R"
    READ(1,*)LOAD_RATIO   
    READ(1,*)!
    READ(1,*)!XBEM NUMBER OF ENRICHED ELEMENTS FOR EACH CRACK TIP PAIR
    READ(1,*)N_ENRICHED_ELEMS
    READ(1,*)!
    READ(1,*)!XBEM NUMBER OF NODES IN SUPPLEMENTARY CONDITION
    READ(1,*)N_ALIGNMENT_NODES
    READ(1,*)!
    READ(1,*)!COHESIVE OPERATOR: "CONSTANT" OR "TANGENT"
    READ(1,*)COHESIVE_OPERATOR
    READ(1,*)!
    READ(1,*)!NUMBER OF INCREMENTS IN COHESIVE ANALYSIS
    READ(1,*)N_COHESIVE_INCREMENTS
    READ(1,*)!
    READ(1,*)!TOLERANCE OF UNBALANCED FORCE VECTOR IN COHESIVE ANALYSIS
    READ(1,*)TOL_F_EXC
!
    VISCO_ANALYSIS=.FALSE.
    DO I=1,N_DOMAINS
        IF (TIME_MODEL(I).NE.4) THEN
            READ(1,*)!
            READ(1,*)!***** WRITE THIS END PART ONLY FOR VISCOELASTIC ANALYSIS ****
            READ(1,*)!
            READ(1,*)! SPECIFT THE TIME STEP SIZE
            READ(1,*)DELTA_T_VISCO
            READ(1,*)!
            ALLOCATE(FINAL_STEP_NUMBER(N_LOAD_FASE))
            READ(1,*)! LOAD_PHASE  FINAL STEP NUMBER
            DO J=1,N_LOAD_FASE
                READ(1,*)JJ,FINAL_STEP_NUMBER(JJ)
            ENDDO
            READ(1,*)!
            READ(1,*)! OBTAIN DATA AT THE BOUNDARY NODES
            READ(1,*)! NUMBER OF NODES
            READ(1,*)N_NODES_BOUND_VISCO
            ALLOCATE(COORDS_BOUND_VISCO(N_NODES_BOUND_VISCO,3))
            READ(1,*)! NODE    X   Y  Z
            DO J=1,N_NODES_BOUND_VISCO
                READ(1,*)JJ,COORDS_BOUND_VISCO(JJ,1),COORDS_BOUND_VISCO(JJ,2),COORDS_BOUND_VISCO(JJ,3)
            ENDDO
            READ(1,*)!
            READ(1,*)! OBTAIN DATA AT THE BOUNDARY NODES
            READ(1,*)! NUMBER OF NODES
            READ(1,*)N_NODES_INT_VISCO
            ALLOCATE(COORDS_INT_VISCO(N_NODES_INT_VISCO,3),NDI_VISCO(N_NODES_INT_VISCO))
            READ(1,*)! NODE   X    Y    Z
            DO J=1,N_NODES_INT_VISCO
                READ(1,*)JJ,COORDS_INT_VISCO(JJ,1),COORDS_INT_VISCO(JJ,2),COORDS_INT_VISCO(JJ,3),NDI_VISCO(JJ)
            ENDDO
                
            NP_TIME = FINAL_STEP_NUMBER(N_LOAD_FASE)
            VISCO_ANALYSIS=.TRUE.
            
            ! allocating viscoelastic variables
            II=N_COLLOCPOINTS
            ALLOCATE(U_ANTERIOR(3*II),T_ANTERIOR(3*II),U_INT_ANTERIOR(3*N_NODES_INT_VISCO),S_ANTERIOR(9*N_NODES_INT_VISCO),&
                S_EL(9*N_NODES_INT_VISCO),S_EL_ANTERIOR(9*N_NODES_INT_VISCO),S_VISCOSA(9*N_NODES_INT_VISCO),FS(3*II),&
                U_INT_VISCO(3*N_NODES_INT_VISCO),S_INT_VISCO(9*N_NODES_INT_VISCO),S_PRINCIPAL(9*N_NODES_INT_VISCO))
            
            EXIT
        ENDIF
    ENDDO   
!
    CLOSE(1)

!
!	DEFINING INTERFACE PAIR OF NODES
!
	TOL=1.0D-10
	N_INTERFACE_POINTS=0
	DO I=1,N_COLLOCPOINTS
		DO J=1,N_COLLOCPOINTS
			IF(I.GT.J) THEN
				DX=COORD_COLLOCPOINTS(I,1)-COORD_COLLOCPOINTS(J,1)
				DY=COORD_COLLOCPOINTS(I,2)-COORD_COLLOCPOINTS(J,2)
		        DZ=COORD_COLLOCPOINTS(I,3)-COORD_COLLOCPOINTS(J,3)
				DR=DSQRT(DX*DX+DY*DY+DZ*DZ)
				IF(DR.LE.TOL) THEN
					II=0
					JJ=0
					DO K=1,N_ELEM
						DO KK=1,4
							IF(COLLOCPOINTS_CONNECTIVITY(K,KK).EQ.I) THEN
								II=ND(K)
							ENDIF
							IF(COLLOCPOINTS_CONNECTIVITY(K,KK).EQ.J) THEN
								JJ=ND(K)
							ENDIF
						ENDDO
					ENDDO
					IF(II.NE.JJ) THEN
						IF(N_INTERFACE_POINTS.EQ.0) THEN
							N_INTERFACE_POINTS=N_INTERFACE_POINTS+1
							ALLOCATE(NI(N_INTERFACE_POINTS,2))
							NI(N_INTERFACE_POINTS,1)=I
							NI(N_INTERFACE_POINTS,2)=J
						ELSE
							ALLOCATE(NIAUX(N_INTERFACE_POINTS,2))
							NIAUX=NI
							DEALLOCATE(NI)
							N_INTERFACE_POINTS=N_INTERFACE_POINTS+1
							ALLOCATE(NI(N_INTERFACE_POINTS,2))
							DO K=1,(N_INTERFACE_POINTS-1)
								NI(K,1)=NIAUX(K,1)
								NI(K,2)=NIAUX(K,2)
							ENDDO
							NI(N_INTERFACE_POINTS,1)=I
							NI(N_INTERFACE_POINTS,2)=J
							DEALLOCATE(NIAUX)
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDDO
	ENDDO
!
!	DEFINING CRACK PAIR OF NODES
!
	TOL=1.0D-10
	N_CRACK_POINTS=0
	DO I=1,N_COLLOCPOINTS
        IF(DUAL_BEM(I).EQ.'S')THEN
            N_CRACK_POINTS=N_CRACK_POINTS+1
        ENDIF
	ENDDO
	IF(N_CRACK_POINTS.GT.0)THEN
	    ALLOCATE(NC(N_CRACK_POINTS,2))   
	    II=0
	    DO I=1,N_COLLOCPOINTS
            IF(DUAL_BEM(I).EQ.'S')THEN
                II=II+1
                NC(II,1)=I
                DO J=1,N_COLLOCPOINTS
                    IF(DUAL_BEM(J).EQ.'H')THEN
                        DX=COORD_COLLOCPOINTS(I,1)-COORD_COLLOCPOINTS(J,1)
				        DY=COORD_COLLOCPOINTS(I,2)-COORD_COLLOCPOINTS(J,2)
		                DZ=COORD_COLLOCPOINTS(I,3)-COORD_COLLOCPOINTS(J,3)
				        DR=DSQRT(DX*DX+DY*DY+DZ*DZ)
				        IF(DR.LE.TOL) THEN
				            NC(II,2)=J
                        ENDIF
                    ENDIF    
                ENDDO
            ENDIF
	    ENDDO	
	ENDIF	  
!
!	EVALUATION OF THE PRESCRIBED BOUNDARY VALUES AT THE COLOCATION POINTS
!
	DO I=1,N_ELEM 
	    NEN=ELEM_TYPE(I)*ORDER_ELEM(I)+(ELEM_TYPE(I)-3)*(ORDER_ELEM(I)-1)*POL_FAMILY(I)
	    DO J=1,NEN
	        IF(DISCONTINUOUS_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J)).NE."CONTINUOUS")THEN
	            ALLOCATE(VALUES(NEN,3),PHI(NEN),DPHI(NEN,2))
			    VALUES=0.D0
			    DO K=1,NEN
			        II=COLLOCPOINTS_CONNECTIVITY(I,J)
			        IF(B_CONDITIONS(3*II-2).EQ.0) THEN
					    VALUES(K,1)=U(3*COLLOCPOINTS_CONNECTIVITY(I,K)-2)
				    ELSE
					    VALUES(K,1)=T(3*COLLOCPOINTS_CONNECTIVITY(I,K)-2)
				    ENDIF
!
				    IF(B_CONDITIONS(3*II-1).EQ.0) THEN
					    VALUES(K,2)=U(3*COLLOCPOINTS_CONNECTIVITY(I,K)-1)
				    ELSE
					    VALUES(K,2)=T(3*COLLOCPOINTS_CONNECTIVITY(I,K)-1)
				    ENDIF
!
				    IF(B_CONDITIONS(3*II).EQ.0) THEN
					    VALUES(K,3)=U(3*COLLOCPOINTS_CONNECTIVITY(I,K))
				    ELSE
					    VALUES(K,3)=T(3*COLLOCPOINTS_CONNECTIVITY(I,K))
				    ENDIF				    
			    ENDDO
			    
			    CALL SHAPE_FUNCTIONS(1,QSI(I,J,1),QSI(I,J,2),NEN,VALUES,COEFFICIENTS,X,Y,Z,PHI,DPHI,D2PHI)
!			    
			    II=COLLOCPOINTS_CONNECTIVITY(I,J)
!			    
			    IF(B_CONDITIONS(3*II-2).EQ.0) THEN
				    U(3*II-2)=X
				ELSE
				    T(3*II-2)=X
				ENDIF
!
				IF(B_CONDITIONS(3*II-1).EQ.0) THEN
				    U(3*II-1)=Y
				ELSE
				    T(3*II-1)=Y
				ENDIF
!
				IF(B_CONDITIONS(3*II).EQ.0) THEN
				    U(3*II)=Z
				ELSE
				    T(3*II)=Z
				ENDIF		
!			    
			    DEALLOCATE(VALUES,PHI,DPHI)
	        ENDIF
	    ENDDO
	ENDDO
!
!	ALLOCATING EDGE CRACKS REMESHING VARIABLES
!
    ALLOCATE(CRACKED_EDGES(N_ELEM,2),CRACKED_ELEM(N_ELEM),COORD_INTERCEPTPOINTS(N_ELEM,4,3),COORD_EXTRAINTERCEPTPOINTS(N_ELEM,3),COORD_BOUNDARYCRACKTIP(N_ELEM,3),NEW_ELEMENTS(N_ELEM,3),COORD_BOUNDARYCRACKTIPSTOP(N_ELEM,2,3),CHANGEABLE_ELEM(N_ELEM),CHANGEABLE_COLLOCPOINTS(N_COLLOCPOINTS))
    CRACKED_EDGES=0  
    NEW_ELEMENTS=0  
    CRACKED_ELEM="UNCRACKED"  
    COORD_INTERCEPTPOINTS=0.D0
    COORD_EXTRAINTERCEPTPOINTS=0.D0
    COORD_BOUNDARYCRACKTIP=0.D0
    COORD_BOUNDARYCRACKTIPSTOP=0.D0
    CHANGEABLE_ELEM="UNCHANGEABLE" 
    CHANGEABLE_COLLOCPOINTS="UNCHANGEABLE"
    MINIMUM_MAXIMUM_LOAD=""        	    	
!
!	DEFINING THE COORDINATE OF COLOCATION POINTS IN THE CASE WHICH
!	THE SOURCE POINT IS NOT AT THE BOUNDARY
!
    IF(DIST.NE.0.D0) THEN
        ALLOCATE(SOURCE_POINT_SPACING(N_COLLOCPOINTS))
        SOURCE_POINT_SPACING=.TRUE.
        ALLOCATE(QSIW_GAUSS(N_GAUSSPOINTS,2))
        CALL GAUSS_POINTS(N_GAUSSPOINTS,QSIW_GAUSS)
   	    DO I=1,N_ELEM
   	        AELEM=0.D0
   	        NEN=ELEM_TYPE(I)*ORDER_ELEM(I)+(ELEM_TYPE(I)-3)*(ORDER_ELEM(I)-1)*POL_FAMILY(I)
   	        ALLOCATE(VALUES(NEN,3))
   	        DO J=1,NEN
		        VALUES(J,1)=COORD_NODES(NODES_CONNECTIVITY(I,J),1)
	            VALUES(J,2)=COORD_NODES(NODES_CONNECTIVITY(I,J),2)
	            VALUES(J,3)=COORD_NODES(NODES_CONNECTIVITY(I,J),3)
	        ENDDO
			DO J=1,N_GAUSSPOINTS
			    DO K=1,N_GAUSSPOINTS
			    	CALL NORMAL_OUTWARD(NEN,VALUES,QSIW_GAUSS(J,1),QSIW_GAUSS(K,1),ETA,VJAC,DVJAC,JAC)
			        AELEM=AELEM+JAC*QSIW_GAUSS(J,2)*QSIW_GAUSS(K,2)
			    ENDDO
			ENDDO
            DO J=1,NEN
                IF(SOURCE_POINT_SPACING(COLLOCPOINTS_CONNECTIVITY(I,J)))THEN
                    CALL NORMAL_OUTWARD(NEN,VALUES,QSI(I,J,1),QSI(I,J,2),ETA,VJAC,DVJAC,JAC)
                    COORD_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J),1)=COORD_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J),1)+ETA(1)*DSQRT(AELEM)*DIST
                    COORD_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J),2)=COORD_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J),2)+ETA(2)*DSQRT(AELEM)*DIST
                    COORD_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J),3)=COORD_COLLOCPOINTS(COLLOCPOINTS_CONNECTIVITY(I,J),3)+ETA(3)*DSQRT(AELEM)*DIST
                ENDIF
                SOURCE_POINT_SPACING(COLLOCPOINTS_CONNECTIVITY(I,J))=.FALSE.    
            ENDDO
            DEALLOCATE(VALUES) 
        ENDDO
    ENDIF
!            	 	 
	END SUBROUTINE INPUT_DATA
!
!
!**** SUBROUTINE FOR UPDATING THE LOAD FASES  ****************************************************************************************************	
!
!
    SUBROUTINE UPDATE_LOAD_FASE
        USE NURBS_SURFACES
        USE ISOPARAMETRIC_MESH
        USE ANALYSIS
        USE XBEM_FORCE_VARIABLES
        USE XBEM_SUPPORT_VARIABLES
        	
        IMPLICIT NONE
        INTEGER::UNOX,UNOY,UNOZ,PNOX,PNOY,PNOZ,I,J,K,II,PREVIOUS_COLLOCPOINTS
        REAL(8)::PRESCRIBED_VALUE
        CHARACTER::BOUND_READ
        ! IMPORT BOUNDARY CONDITIONS OF 3 POINT BENDING
        INTEGER::NODE,NUM_BCS,NODES_BC[ALLOCATABLE](:),TYPE_BC[ALLOCATABLE](:)
        REAL(8)::VALUE_BC[ALLOCATABLE](:)
    
        READ(1,*)!********************************* LOAD PHASE  **********
        READ(1,*)!
        READ(1,*)! GIVE VALUES PER NODE (N) OR PER PATCH (P) ?                      ! MUDOU
        READ(1,*)BOUND_READ                                                         ! MUDOU
        READ(1,*)!
        READ(1,*)! NUMBER OF NURBS SURFACES WITH DISPLACEMENT X PRESCRIBED:
        READ(1,*)UNOX
        READ(1,*)!
        READ(1,*)! NUMBER OF NURBS SURFACES WITH DISPLACEMENT Y PRESCRIBED:
        READ(1,*)UNOY
        READ(1,*)!
        READ(1,*)! NUMBER OF NURBS SURFACES WITH DISPLACEMENT Z PRESCRIBED:
        READ(1,*)UNOZ
        READ(1,*)!
        READ(1,*)! NUMBER OF NURBS SURFACES WITH NON NULL TRACTION X PRESCRIBED:
        READ(1,*)PNOX
        READ(1,*)!
        READ(1,*)! NUMBER OF NURBS SURFACES WITH NON NULL TRACTION Y PRESCRIBED:
        READ(1,*)PNOY
        READ(1,*)!
        READ(1,*)! NUMBER OF NURBS SURFACES WITH NON NULL TRACTION Y PRESCRIBED:
        READ(1,*)PNOZ
        READ(1,*)!
        READ(1,*)! NUMBER OF CONCENTRATED LOADS 
        READ(1,*)NUM_CON_LOADS
        READ(1,*)!
        READ(1,*)! NUMBER OF CONCENTRATED SUPPORTS
        READ(1,*)NUM_CON_SUPPS
        READ(1,*)!
        READ(1,*)! NUMBER OF ENRICHED DISTRIBUTED LOADS 
        READ(1,*)NUM_DIST_LOADS
        READ(1,*)!
        READ(1,*)! NUMBER OF ENRICHED DISTRIBUTED SUPPORTS WITH DISPLACEMENT X PRESCRIBED 
        READ(1,*)NUM_DIST_SUPPS_X
        READ(1,*)!
        READ(1,*)! NUMBER OF ENRICHED DISTRIBUTED SUPPORTS WITH DISPLACEMENT Y PRESCRIBED 
        READ(1,*)NUM_DIST_SUPPS_Y
        READ(1,*)!
        READ(1,*)! NUMBER OF ENRICHED DISTRIBUTED SUPPORTS WITH DISPLACEMENT Y PRESCRIBED 
        READ(1,*)NUM_DIST_SUPPS_Z
        READ(1,*)!
        READ(1,*)! VALUES OF DISPLACEMENT X PRESCRIBED	
        IF(UNOX.NE.0) THEN
	        DO I=1,UNOX
		        READ(1,*)! PATCH
		        READ(1,*)II
		        PREVIOUS_COLLOCPOINTS=0
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		        ELSE
		            DO J=1,N_SURFACES
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).NE."UNTRIMMED")THEN 
                            PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(J)
                        ENDIF
                    ENDDO        
		        ENDIF      
		        READ(1,*)! VALUES
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
                    IF (SURFACE_TYPE(II).EQ."B")THEN 
                        IF (DESCONT_TYPE(II).EQ."DB") THEN
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        READ(1,*)PRESCRIBED_VALUE
			                        U(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=0
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        U(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=0
                                ENDDO
                            ENDIF
                        ELSE
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        READ(1,*)PRESCRIBED_VALUE
			                        U(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=0
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        U(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=0
                                ENDDO
                            ENDIF
                        ENDIF
                    ELSE
                        IF (BOUND_READ.EQ.'N') THEN
		                    DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    READ(1,*)PRESCRIBED_VALUE
			                    U(3*J-2)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-2)=0
                            ENDDO		
                        ELSE
                            READ(1,*)PRESCRIBED_VALUE
                            DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    U(3*J-2)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-2)=0
                            ENDDO	
                        ENDIF
		            ENDIF
		        ELSE
		            READ(1,*)PRESCRIBED_VALUE
	                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(II)
		                U(3*J-2)=PRESCRIBED_VALUE
		                B_CONDITIONS(3*J-2)=0
	                ENDDO		        
		        ENDIF        
	        ENDDO
        ELSE
	        READ(1,*)! PATCH
	        READ(1,*)!
	        READ(1,*)! VALUES
        ENDIF

        READ(1,*)!
        READ(1,*)! VALUES OF DISPLACEMENT Y PRESCRIBED	
        IF(UNOY.NE.0) THEN
	        DO I=1,UNOY
		        READ(1,*)! PATCH
		        READ(1,*)II
		        PREVIOUS_COLLOCPOINTS=0
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		        ELSE
		            DO J=1,N_SURFACES
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).NE."UNTRIMMED")THEN 
                            PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(J)
                        ENDIF
                    ENDDO        
		        ENDIF   
		        READ(1,*)! VALUES
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
                    IF (SURFACE_TYPE(II).EQ."B")THEN 
                        IF (DESCONT_TYPE(II).EQ."DB") THEN
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        READ(1,*)PRESCRIBED_VALUE
			                        U(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=0
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        U(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=0
                                ENDDO
                            ENDIF
                        ELSE
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        READ(1,*)PRESCRIBED_VALUE
			                        U(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=0
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        U(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=0
                                ENDDO
                            ENDIF
                        ENDIF
                    ELSE
                        IF (BOUND_READ.EQ.'N') THEN
		                    DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    READ(1,*)PRESCRIBED_VALUE
			                    U(3*J-1)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-1)=0
                            ENDDO		
                        ELSE
                            READ(1,*)PRESCRIBED_VALUE
                            DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    U(3*J-1)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-1)=0
                            ENDDO
                        ENDIF
		            ENDIF 
		        ELSE
		            READ(1,*)PRESCRIBED_VALUE
	                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(II)
		                U(3*J-1)=PRESCRIBED_VALUE
		                B_CONDITIONS(3*J-1)=0
	                ENDDO		        
		        ENDIF		                   
	        ENDDO
        ELSE
	        READ(1,*)! PATCH
	        READ(1,*)!
	        READ(1,*)! VALUES
        ENDIF
        
        READ(1,*)!
        READ(1,*)! VALUES OF DISPLACEMENT Z PRESCRIBED	
        IF(UNOZ.NE.0) THEN
	        DO I=1,UNOZ
		        READ(1,*)! PATCH
		        READ(1,*)II
		        PREVIOUS_COLLOCPOINTS=0
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))            
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		        ELSE
		            DO J=1,N_SURFACES
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))            
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).NE."UNTRIMMED")THEN 
                            PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(J)
                        ENDIF
                    ENDDO        
		        ENDIF   
		        READ(1,*)! VALUES
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
                    IF (SURFACE_TYPE(II).EQ."B")THEN  
                        IF (DESCONT_TYPE(II).EQ."DB") THEN
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        READ(1,*)PRESCRIBED_VALUE
			                        U(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=0
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        U(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=0
                                ENDDO
                            ENDIF   
                        ELSE
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        READ(1,*)PRESCRIBED_VALUE
			                        U(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=0
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        U(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=0
                                ENDDO
                            ENDIF
                        ENDIF
                    ELSE
                        IF (BOUND_READ.EQ.'N') THEN
		                    DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    READ(1,*)PRESCRIBED_VALUE
			                    U(3*J)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J)=0
                            ENDDO	
                        ELSE
                            READ(1,*)PRESCRIBED_VALUE
                            DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    U(3*J)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J)=0
                            ENDDO	
                        ENDIF
		            ENDIF 
		        ELSE
		            READ(1,*)PRESCRIBED_VALUE
	                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(II)
		                U(3*J)=PRESCRIBED_VALUE
		                B_CONDITIONS(3*J)=0
	                ENDDO		        
		        ENDIF		                
	        ENDDO
        ELSE
	        READ(1,*)! PATCH
	        READ(1,*)!
	        READ(1,*)! VALUES
        ENDIF

        READ(1,*)!
        READ(1,*)! VALUES OF NON NULL TRACTION X PRESCRIBED	
        IF(PNOX.NE.0) THEN
	        DO I=1,PNOX
		        READ(1,*)! PATCH
		        READ(1,*)II
		        PREVIOUS_COLLOCPOINTS=0
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))            
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		        ELSE
		            DO J=1,N_SURFACES
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))            
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).NE."UNTRIMMED")THEN 
                            PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(J)
                        ENDIF
                    ENDDO        
		        ENDIF   
		        READ(1,*)! VALUES
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
                    IF (SURFACE_TYPE(II).EQ."B")THEN 
                        IF (DESCONT_TYPE(II).EQ."DB") THEN
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        READ(1,*)PRESCRIBED_VALUE
			                        T(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=1
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        T(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=1
                                ENDDO
                            ENDIF 
                        ELSE
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        READ(1,*)PRESCRIBED_VALUE
			                        T(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=1
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        T(3*J-2)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-2)=1
                                ENDDO
                            ENDIF
                        ENDIF
                    ELSE
                        IF (BOUND_READ.EQ.'N') THEN
		                    DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    READ(1,*)PRESCRIBED_VALUE
			                    T(3*J-2)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-2)=1
                            ENDDO	
                        ELSE
                            READ(1,*)PRESCRIBED_VALUE
                            DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    T(3*J-2)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-2)=1
                            ENDDO
                        ENDIF
		            ENDIF 
		        ELSE
		            READ(1,*)PRESCRIBED_VALUE
	                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(II)
		                T(3*J-2)=PRESCRIBED_VALUE
		                B_CONDITIONS(3*J-2)=1
	                ENDDO		        
		        ENDIF			                  
	        ENDDO
        ELSE
	        READ(1,*)! PATCH
	        READ(1,*)!
	        READ(1,*)! VALUES
        ENDIF

        READ(1,*)!
        READ(1,*)! VALUES OF NON NULL TRACTION Y PRESCRIBED	
        IF(PNOY.NE.0) THEN
	        DO I=1,PNOY
		        READ(1,*)! PATCH
		        READ(1,*)II
		        PREVIOUS_COLLOCPOINTS=0
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		        ELSE
		            DO J=1,N_SURFACES
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).NE."UNTRIMMED")THEN 
                            PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(J)
                        ENDIF
                    ENDDO        
		        ENDIF   
		        READ(1,*)! VALUES
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
                    IF (SURFACE_TYPE(II).EQ."B")THEN 
                        IF (DESCONT_TYPE(II).EQ."DB") THEN
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        READ(1,*)PRESCRIBED_VALUE
			                        T(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=1
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        T(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=1
                                ENDDO
                            ENDIF
                        ELSE
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        READ(1,*)PRESCRIBED_VALUE
			                        T(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=1
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        T(3*J-1)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J-1)=1
                                ENDDO
                            ENDIF
                        ENDIF
                    ELSE
                        IF (BOUND_READ.EQ.'N') THEN
		                    DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    READ(1,*)PRESCRIBED_VALUE
			                    T(3*J-1)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-1)=1
                            ENDDO		
                        ELSE
                            READ(1,*)PRESCRIBED_VALUE
                            DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    T(3*J-1)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J-1)=1
                            ENDDO	
                        ENDIF
		            ENDIF  
		        ELSE
		            READ(1,*)PRESCRIBED_VALUE
	                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(II)
		                T(3*J-1)=PRESCRIBED_VALUE
		                B_CONDITIONS(3*J-1)=1
	                ENDDO		        
		        ENDIF			                 
	        ENDDO
        ELSE
	        READ(1,*)! PATCH
	        READ(1,*)!
	        READ(1,*)! VALUES
        ENDIF
        
        READ(1,*)!
        READ(1,*)! VALUES OF NON NULL TRACTION Z PRESCRIBED	
        IF(PNOZ.NE.0) THEN
	        DO I=1,PNOZ
		        READ(1,*)! PATCH
		        READ(1,*)II
		        PREVIOUS_COLLOCPOINTS=0
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		        ELSE
		            DO J=1,N_SURFACES
		                IF(TRIMMED_SURFACE(J).EQ."UNTRIMMED")THEN     
                            SELECT CASE (SURFACE_TYPE(J))
                            CASE("B")
                                IF (DESCONT_TYPE(J).EQ."DB") THEN
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(J))*(SUBDIVISION_PD2(J))        
                                ELSE
                                    PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(J)+1)*(SUBDIVISION_PD2(J)+1)        
                                ENDIF
                            CASE("CI")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CD")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)
                            CASE("CT")
                                PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(J)*SUBDIVISION_PD2(J)        
                            ENDSELECT
                        ENDIF    
		            ENDDO
		            DO J=1,II-1
		                IF(TRIMMED_SURFACE(J).NE."UNTRIMMED")THEN 
                            PREVIOUS_COLLOCPOINTS=PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(J)
                        ENDIF
                    ENDDO        
		        ENDIF    
		        READ(1,*)! VALUES
		        IF(TRIMMED_SURFACE(II).EQ."UNTRIMMED")THEN
                    IF (SURFACE_TYPE(II).EQ."B")THEN 
                        IF (DESCONT_TYPE(II).EQ."DB") THEN
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        READ(1,*)PRESCRIBED_VALUE
			                        T(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=1
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*(SUBDIVISION_PD1(II))*(SUBDIVISION_PD2(II))
			                        T(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=1
                                ENDDO
                            ENDIF   
                        ELSE
                            IF (BOUND_READ.EQ.'N') THEN
		                        DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        READ(1,*)PRESCRIBED_VALUE
			                        T(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=1
                                ENDDO
                            ELSE
                                READ(1,*)PRESCRIBED_VALUE
                                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+(SUBDIVISION_PD1(II)+1)*(SUBDIVISION_PD2(II)+1)
			                        T(3*J)=PRESCRIBED_VALUE
			                        B_CONDITIONS(3*J)=1
                                ENDDO
                            ENDIF
                        ENDIF
                    ELSE
                        IF (BOUND_READ.EQ.'N') THEN
		                    DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    READ(1,*)PRESCRIBED_VALUE
			                    T(3*J)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J)=1
                            ENDDO
                        ELSE
                            READ(1,*)PRESCRIBED_VALUE
                            DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+4*SUBDIVISION_PD1(II)*SUBDIVISION_PD2(II)
			                    T(3*J)=PRESCRIBED_VALUE
			                    B_CONDITIONS(3*J)=1
                            ENDDO
                        ENDIF
		            ENDIF  
		        ELSE
		            READ(1,*)PRESCRIBED_VALUE
	                DO J=PREVIOUS_COLLOCPOINTS+1,PREVIOUS_COLLOCPOINTS+N_COLLOCPOINTS_SURFACES(II)
		                T(3*J)=PRESCRIBED_VALUE
		                B_CONDITIONS(3*J)=1
	                ENDDO		        
		        ENDIF		                 
	        ENDDO
        ELSE
	        READ(1,*)! PATCH
	        READ(1,*)!
	        READ(1,*)! VALUES
        ENDIF
        READ(1,*)
        READ(1,*)! CONCENTRATED LOAD DATA
        ALLOCATE(COORDS_CON_LOADS(NUM_CON_LOADS,3), VALUES_CON_LOADS(NUM_CON_LOADS,3))
        READ(1,*)! COORD X		COORD Y		COORD Z		FX		FY		FZ
        DO I=1,NUM_CON_LOADS
            READ(1,*)COORDS_CON_LOADS(I,1),COORDS_CON_LOADS(I,2),COORDS_CON_LOADS(I,3),VALUES_CON_LOADS(I,1),VALUES_CON_LOADS(I,2),VALUES_CON_LOADS(I,3)
        ENDDO
        READ(1,*)
        READ(1,*)! CONCENTRATED SUPPORT DATA
        ALLOCATE(COORDS_CON_SUPPS(NUM_CON_SUPPS,3),DIR_CON_SUPPS(NUM_CON_SUPPS),VALUES_CON_SUPPS(NUM_CON_SUPPS))
        READ(1,*)! COORD X		COORD Y		COORD Z		DIR			U
        DO I=1,NUM_CON_SUPPS
            READ(1,*)COORDS_CON_SUPPS(I,1),COORDS_CON_SUPPS(I,2),COORDS_CON_SUPPS(I,3),DIR_CON_SUPPS(I),VALUES_CON_SUPPS(I)
        ENDDO
        READ(1,*)!
        READ(1,*)! ENRICHED DISTRIBUTED LOAD DATA
        ALLOCATE(COORDS_DIST_LOADS(NUM_DIST_LOADS,4,3),VALUES_DIST_LOADS(NUM_DIST_LOADS,3,4))
        DO I=1,NUM_DIST_LOADS
            READ(1,*)!AREA
            READ(1,*)II
            READ(1,*)! COORD X		COORD Y		COORD Z		FX		FY		FZ
            DO J=1,4
                READ(1,*)COORDS_DIST_LOADS(II,J,1),COORDS_DIST_LOADS(II,J,2),COORDS_DIST_LOADS(II,J,3),VALUES_DIST_LOADS(II,1,J),VALUES_DIST_LOADS(II,2,J),VALUES_DIST_LOADS(II,3,J)
            ENDDO
        ENDDO
        READ(1,*)
        READ(1,*)! ENRICHED DISTRIBUTED SUPPORT DATA
        READ(1,*)! NUMBER OF NODES IN ENRICHED AREA WITH PRESCRIBED DISPLACEMENT IN X DIRECTION
        READ(1,*)NODES_DIST_SUPPS_X
        ALLOCATE(COORDS_DIST_SUPPS_X(NODES_DIST_SUPPS_X,3),VALUES_DIST_SUPPS_X(NODES_DIST_SUPPS_X),CONEC_DIST_SUPPS_X(NUM_DIST_SUPPS_X,4))
        READ(1,*)!
        READ(1,*)!COORD X 	COORD Y		COORD Z		VALUE
        DO I=1,NODES_DIST_SUPPS_X
            READ(1,*)COORDS_DIST_SUPPS_X(I,1),COORDS_DIST_SUPPS_X(I,2),COORDS_DIST_SUPPS_X(I,3),VALUES_DIST_SUPPS_X(I)
        ENDDO
        READ(1,*)!
        READ(1,*)! CONNECTIVITY
        READ(1,*)! NODE1	NODE2	NODE3	NODE4
        DO I=1,NUM_DIST_SUPPS_X
            READ(1,*)CONEC_DIST_SUPPS_X(I,1),CONEC_DIST_SUPPS_X(I,2),CONEC_DIST_SUPPS_X(I,3),CONEC_DIST_SUPPS_X(I,4)
        ENDDO
        READ(1,*)!
        READ(1,*)! NUMBER OF NODES IN ENRICHED AREA WITH PRESCRIBED DISPLACEMENT IN Y DIRECITON
        READ(1,*)NODES_DIST_SUPPS_Y
        ALLOCATE(COORDS_DIST_SUPPS_Y(NODES_DIST_SUPPS_Y,3),VALUES_DIST_SUPPS_Y(NODES_DIST_SUPPS_Y),CONEC_DIST_SUPPS_Y(NUM_DIST_SUPPS_Y,4))
        READ(1,*)!
        READ(1,*)!COORD X 	COORD Y		COORD Z		VALUE
        DO I=1,NODES_DIST_SUPPS_Y
            READ(1,*)COORDS_DIST_SUPPS_Y(I,1),COORDS_DIST_SUPPS_Y(I,2),COORDS_DIST_SUPPS_Y(I,3),VALUES_DIST_SUPPS_Y(I)
        ENDDO
        READ(1,*)!
        READ(1,*)! CONNECTIVITY
        READ(1,*)! NODE1	NODE2	NODE3	NODE4
        DO I=1,NUM_DIST_SUPPS_Y
            READ(1,*)CONEC_DIST_SUPPS_Y(I,1),CONEC_DIST_SUPPS_Y(I,2),CONEC_DIST_SUPPS_Y(I,3),CONEC_DIST_SUPPS_Y(I,4)
        ENDDO
        READ(1,*)!
        READ(1,*)! NUMBER OF NODES IN ENRICHED AREA WITH PRESCRIBED DISPLACEMENT IN Z DIRECITON
        READ(1,*)NODES_DIST_SUPPS_Z
        ALLOCATE(COORDS_DIST_SUPPS_Z(NODES_DIST_SUPPS_Z,3),VALUES_DIST_SUPPS_Z(NODES_DIST_SUPPS_Z),CONEC_DIST_SUPPS_Z(NUM_DIST_SUPPS_Z,4))
        READ(1,*)!
        READ(1,*)!COORD X 	COORD Y		COORD Z		VALUE
        DO I=1,NODES_DIST_SUPPS_Z
            READ(1,*)COORDS_DIST_SUPPS_Z(I,1),COORDS_DIST_SUPPS_Z(I,2),COORDS_DIST_SUPPS_Z(I,3),VALUES_DIST_SUPPS_Z(I)
        ENDDO
        READ(1,*)!
        READ(1,*)! CONNECTIVITZ
        READ(1,*)! NODE1	NODE2	NODE3	NODE4
        DO I=1,NUM_DIST_SUPPS_Z
            READ(1,*)CONEC_DIST_SUPPS_Z(I,1),CONEC_DIST_SUPPS_Z(I,2),CONEC_DIST_SUPPS_Z(I,3),CONEC_DIST_SUPPS_Z(I,4)
        ENDDO
        READ(1,*)!
        READ(1,*)
        NUM_DIST_SUPPS=NUM_DIST_SUPPS_X+NUM_DIST_SUPPS_Y+NUM_DIST_SUPPS_Z
        NODES_DIST_SUPPS=NODES_DIST_SUPPS_X+NODES_DIST_SUPPS_Y+NODES_DIST_SUPPS_Z
        ALLOCATE(VALUES_DIST_SUPPS(NODES_DIST_SUPPS))     		    	                                                                                  
!                   			    
    END SUBROUTINE UPDATE_LOAD_FASE

